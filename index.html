<html>
<head>
	<title>into the Maze</title>
	<link rel="stylesheet" href="./css/style.css" />
	<script src="js/three.min.js"></script>

<script>
	// to select elements from html
	var $$ = (e) => document.querySelector(e);
	var $ = (p, e) => p.querySelector(e);
	var make = (n) => document.createElement(n);
	var div = () => make('div');
	function addClass(ele, name){
		if(ele.className.match(name) == null)
			ele.className += (" " + name);
	}
	function removeClass(ele, name){
		var c = ele.className
		if(c.match(name) != null)
			ele.className = c.replace(name, "");
	}

	// GAME CONSTANTS
	const MAZE_DIMS = 10;
	
	const WAITING = 1;
	const TURNING_RIGHT = 2;
	const TURNING_LEFT = 3;
	const MOVING_FORWARD = 4;
	const FADING_OUT = 10;
	const DONE = 11;
	const FADING_IN = 13;
	const START = 14;

	const NORTH = 100;
	const EAST = 101;
	const WEST = 102;
	const SOUTH = 103;

	var playerInput;
	var t = null;
	
	var game = (function(){
		playerInput = new Object();
		var state = START;	
		var currentDirection = 0;
		var turningArc = 0;
		var direction = NORTH;
		var walkDistance = 0;
		var startX = 0;
		var startZ = 0;
		var last_update = Date.now();
		var flag=0;
		var stop_render = false;
		var empty_positions = (new Array(MAZE_DIMS)).fill(0).map(() => new Array(MAZE_DIMS).fill(0))

		var player = {};
		player.gridX = 0;
		player.gridY = 0;
		player.direction = NORTH;


		/***

		Initial function that gets called to start the game

		***/

		
		function runMaze(){
		    // get HTML canvas element and set size
		    var mazeCanvas = document.getElementById("mazeCanvas");
		    mazeCanvas.width = document.body.offsetWidth;
		    mazeCanvas.height = document.body.offsetHeight;

		    // create scene, WEBGL renderer and camera
		    var scene = new THREE.Scene();
		    var renderer = new THREE.WebGLRenderer({ canvas: mazeCanvas });
		    var camera = new THREE.PerspectiveCamera( 75, mazeCanvas.width/mazeCanvas.height, 0.1, 1000 );
		    t = camera;

		    var mazeGrid = createMazeGrid(MAZE_DIMS, MAZE_DIMS);
		 	placeWallGraphics(scene, mazeGrid);	    

		    var collectables = createCollectiblesList(empty_positions);
		    collectables=placeCollectableGraphics(scene, collectables);
		    var obstacles = createObstaclesList(empty_positions);
		    obstacles=placeObstacleGraphics(scene, obstacles);
		    var inventory = new Inventory($$("#inventory"), collectables);

		    var score_man = new ScoreManager($$("#score"), collectables, {
		    	aim: 0,
		    	action: inventory.giveKey
		    });
		    var nobox = true;

		    createDoor(scene);
		    createDoor(scene, -0.055)

		   	// create Light source
		   	var playerPointLight = new THREE.PointLight();
		   	playerPointLight.position.set(0,0,0);
		   	scene.add(playerPointLight);

		   	var render = function () {
		   		var now = Date.now();
		   		var deltaTime = now - last_update;
		   		last_update = now;
		   		if(state == START){
		   			scene.children.forEach( ({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity = 0;
							return material.opacity;
						}
						return 0;
					});

					state = FADING_IN;
		   		}else if(state == FADING_IN){
		   			var ops = scene.children.map(({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity += 0.03;
							return material.opacity;
						}
						return 1;
					}).filter( e => e < 1);
		   			if(ops.length == 0){
		   				state = WAITING;
		   			}

		   		}

		   		
				if(state == WAITING){  // waiting for user input
					   // if player has given an input, make a move
					if(playerInput.left){
					   	state = TURNING_LEFT;
					   	switch(direction){
					   		case NORTH:
					   		direction = WEST;
					   		break;
					   		case EAST:
					   		direction = NORTH;
					   		break;
					   		case SOUTH:
					   		direction = EAST;
					   		break;
					   		case WEST:
					   		direction = SOUTH;
					   		break;
					   	}
						   player.direction = direction; //Sync player and camera
					}
					else if(playerInput.right){
						state = TURNING_RIGHT;
						switch(direction){
							case NORTH:
							direction = EAST;
							break;
							case EAST:
							direction = SOUTH;
							break;
							case SOUTH:
							direction = WEST;
							break;
							case WEST:
							direction = NORTH;
							break;
						}
					   player.direction = direction; //Sync player and camera
					}
					else if (playerInput.up ){
						if(validMove(mazeGrid, player.gridX, player.gridY, player.direction)){
							walkingDistance = 0;
							startX = camera.position.x;
							startZ = camera.position.z;
							state = MOVING_FORWARD;
							switch(direction){
								case NORTH:
								player.gridX--;
								break;
								case EAST:
								player.gridY++;
								break;
								case SOUTH:
								player.gridX++;
								break;
								case WEST:
								player.gridY--;
								break;
							}
						}else{
							// shake animation 
						}
					}else if(playerInput.enter){
						// console.log(player);
						if(inventory.hasKey && direction == NORTH
							&& player.gridX == 0 && player.gridY == 0){
							state = FADING_OUT;
							// console.log("Yay, level done!");
						}
					}
				}

				if(state == FADING_OUT){
					var ops = scene.children.map( ({material}) => {
						if(material){
							material.transparent = true;	
							material.opacity -= 0.03;
							return material.opacity;
						}
						return 0;
					}).filter(e => e > 0);

					if(ops.length == 0){
						state = DONE;
					}
				}
				if(state == DONE){
					if(nobox){
						nobox = false;
						var doNothing = () => {};

						function stopGame(){
							// destroy current scene, camera etc
							stop_render = true;

							// We are using a recursive call to start the next game.
							// dispose everything, so that GC can collect it,
							// although scope is not destroyed


							// from a discourse thread
							renderer.dispose();
							const cleanMaterial = material => {
								// console.log('dispose material!')
								material.dispose()

								// dispose textures
								for (const key of Object.keys(material)) {
									const value = material[key]
									if (value && typeof value === 'object' && 'minFilter' in value) {
										// console.log('dispose texture!')
										value.dispose()
									}
								}
							}

							scene.traverse(object => {
								if (!object.isMesh) return
								// console.log('dispose geometry!')
								object.geometry.dispose()
								if (object.material.isMaterial) {
									cleanMaterial(object.material)
								} else {
									// an array of materials
									for (const material of object.material) cleanMaterial(material)
								}
							})

							scene = null;
							camera = null;
							renderer = null;
							
							
						}
						inventory.dispose();
						score_man.dispose();
						// wait a few secs for suspense and animations
						setTimeout(() => {
							displayMessage("Ready for the next one?", ["Yes", () => {
								stopGame();
								game();
							}], ["No", stopGame]) 
						}, 400);
					}
				}

				if(state == TURNING_LEFT){
					turningArc += Math.PI/2  * deltaTime/1000;
					if(turningArc >= Math.PI/2){
						turningArc = Math.PI/2;
						currentDirection = currentDirection + turningArc;
						turningArc = 0;
						state = WAITING;
					}

					camera.rotation.y = currentDirection + turningArc;
				}

				if(state == TURNING_RIGHT){
					turningArc += Math.PI/2  * deltaTime/1000;
					if(turningArc >= Math.PI/2){
						turningArc = Math.PI/2;
						currentDirection = currentDirection - turningArc;
						turningArc = 0;
						state = WAITING;
					}

					camera.rotation.y = currentDirection - turningArc;
				}

				if(state == MOVING_FORWARD)
				{

					walkingDistance += 1 * deltaTime/1000;
					if(walkingDistance >= 1){
						walkingDistance = 1;
						state = WAITING;
						collectables=processCollectableCollisions(player.gridX, player.gridY,collectables,scene)
						obstacles=processObstacleCollisions(player.gridX, player.gridY,obstacles,scene)
					}
					switch(direction){
						case NORTH:
						camera.position.z = startZ - walkingDistance;
						break;
						case EAST:
						camera.position.x = startX + walkingDistance;
						break;
						case SOUTH:
						camera.position.z = startZ + walkingDistance;
						break;
						case WEST:
						camera.position.x = startX - walkingDistance;
						break;
					}
					playerPointLight.position.x = camera.position.x;
					playerPointLight.position.y = camera.position.y;
					playerPointLight.position.z = camera.position.z;
					// 	collectables.forEach(function(collectable){
						
					//    var collectableObject = scene.getObjectById( collectables.id);
					//    if (flag++<10) console.log(collectableObject.id);
					//    collectableObject.rotation.x += 2 * deltaTime/1000;
					//    collectableObject.rotation.y += 2 * deltaTime/1000;

					// });
				}
				if(!stop_render){
					scene.traverse (function (object){	
						if (object.name==='collect'){
							object.rotation.x += 2 * deltaTime/1000;
							object.rotation.y += 2 * deltaTime/1000;
						}

					});
					renderer.render(scene, camera);
					// recursive call [ call when js animation micro-calls are done]
					requestAnimationFrame( render );
				}
			};

			render();
		}
		runMaze()
	});

	

	// check if move is
	function validMove(mazeGrid, x, y, direction){
		if(direction == NORTH)
		{
			return !mazeGrid[x][y].northWall;
		}
		else if(direction == EAST)
		{
			return !mazeGrid[x][y].eastWall;
		}
		else if(direction == SOUTH)
		{
			return !mazeGrid[x][y].southWall;
		}
		else if(direction == WEST)
		{
			return !mazeGrid[x][y].westWall;
		}
		return false;
	}


	// create maze
	function createMazeGrid(width, height){
		function MazeCell(northWall, eastWall, southWall, westWall){
			this.northWall = northWall;
			this.eastWall = eastWall;
			this.southWall = southWall;
			this.westWall = westWall;
		}
		MazeCell.prototype.print = function() {
			// var str = "";
			var str = ["   ", "    ", "   "];
			if(this.northWall){
				str[0] = " -- ";
			}

			if(this.westWall){
				str[1] = "|" + str[1].slice(1);
				console.log(str[1])
			}

			if(this.eastWall){
				str[1] =  str[1].slice(0, 3) + "|";
				// str[1][3] += '|';
			}
			
			if(this.southWall){
				str[2] = " -- ";
			}
			
			return str;
		};
		var mazeGrid = Array(height);

		for( var i = 0; i<height; i++){
			var row = Array(width);
			for(var j = 0; j<width; j++){
				row[j] = new MazeCell(true,true,true,true);
			}
			mazeGrid[i] = row;

		}
		for( var i = 0; i<height; i++){
			for(var j = 0; j<width; j++){
		      if(i>0 && j>0){ //If it is not an edge cell open a passage randomly
		      	if(Math.random()>0.5){
		      		mazeGrid[i][j].northWall=false;
		      		mazeGrid[i-1][j].southWall=false;
		      	}
		      	else{
		      		mazeGrid[i][j].westWall=false;
		      		mazeGrid[i][j-1].eastWall=false;
		      	}
		      }
		      else if(j > 0){ //If it is along the north edge open a west passage
		      	mazeGrid[i][j].westWall=false;
		      	mazeGrid[i][j-1].eastWall=false;
		      }
		      else if(i > 0){ //If it is along the west edge open a north passage
		      	mazeGrid[i][j].northWall=false;
		      	mazeGrid[i-1][j].southWall=false;
		      }
		  }
		}
		
		console.log(mazeGrid.map(row=> row.map(cell=> cell.print()).reduce((acc, ele) => {
			ele.forEach((e, i) => acc[i] += e);
			return acc;
		}, ["", "", ""])));

		return mazeGrid;
	}


	// place wall graphics on screen
	function placeWallGraphics(scene, mazeGrid){

		var wallGeometry = new THREE.BoxGeometry( 1.059, 0.5 ,0.06);
		const loader = new THREE.TextureLoader();
		var wallMaterial = new THREE.MeshPhongMaterial({map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2zL8u2_YcU9nXs1KpYGrDWqRO3L55FC4rnewIqV6AC7TjzdHO2w'),});

		mazeGrid.forEach(function(mazeRow, rowCount){
			mazeRow.forEach(function(mazeCell, colCount){
				if(mazeCell.northWall)
					placeWall(colCount, rowCount, 'n');
				if(mazeCell.eastWall)
					placeWall(colCount, rowCount, 'e');
				if(mazeCell.southWall)
					placeWall(colCount, rowCount, 's');
				if(mazeCell.westWall)
					placeWall(colCount, rowCount, 'w');
				var floorGeometry=new THREE.PlaneGeometry(1,1,0.1);
				const loader = new THREE.TextureLoader();
				var floorMaterial = new THREE.MeshPhongMaterial({map: loader.load('https://www.tonytextures.com/free-texture-gallery/stone/Stone_Texture_A_P2140754.JPG'),});
				var floor= new THREE.Mesh(floorGeometry,floorMaterial);
				floor.position.z=rowCount;
				floor.position.x=colCount;
				floor.position.y=-0.25;
				floor.rotation.x=-Math.PI/2;
				scene.add(floor);
			});
		});

		function placeWall(x,y,direction){
			var wall = new THREE.Mesh( wallGeometry, wallMaterial );
			wall.name='wall';
			wall.position.z = y*1;
			wall.position.x = x*1;
			if(direction == 'n'){
				wall.position.z -= 0.5;
			}
			else if(direction == 'e'){
				wall.position.x += 0.5;
				wall.rotation.y = -Math.PI/2;
			}
			else if(direction == 's'){
				wall.position.z += 0.5;
				wall.rotation.y = Math.PI;
			}
			else if(direction == 'w'){
				wall.position.x -= 0.5;
				wall.rotation.y = Math.PI/2;
			}
			else{
				return false;
			}

			scene.add(wall);
		}
	}

	/*****
		Score Manager
	****/
	function ScoreManager(ele, collectables, target){

		// hook a notification function on the collectables
		collectables.forEach(m => m.hook(this.notification.bind(this)))
		this.ele = ele;
		var {aim, action}= target;
		this.aim = aim;
		this.action = action;
		addClass(this.ele, "active");
		this.update(0);
	}
	
	// notified by collectable when it is collected
	ScoreManager.prototype.notification = function(collectable){
		this.update(this.score + collectable.score);
		// console.log("ScoreManager says  score is ", this.score);
		if(this.score >= this.aim){
			this.action();
		}
	}

	ScoreManager.prototype.update = function(n){
		this.score = n;
		$(this.ele, "p").innerText = this.score;
	}

	ScoreManager.prototype.dispose = function(){
		console.log("dispose score manager");
		removeClass(this.ele, "active");		
	}

	/*****
		Inventory Manager
	****/
	function Inventory(container, collectables){
		this.collectables = collectables;
		this.collectedTypes = {}
		this.container = container;

		// hook a notification function on the collectables
		this.collectables.forEach(m => {
			this.collectedTypes[m.type] = false;
			m.hook(this.notification.bind(this))
		});
		this.panel = {};
		var scope = this;

		this.collectables.map(ele => {
			var o = scope.createDisplay(ele);
			this.panel[ele.id] = o;
			return o;
		}).forEach(ele => {
			container.appendChild(ele);
		})
		this.key = this.createKey();
		container.appendChild(this.key);

		this.hasKey = false;

		// will be called by another function.
		// so, bind this to my scope.
		this.giveKey = this.giveKey.bind(this);
		addClass(container, "active");

	}



	Inventory.prototype.createKey = function(){
		var keyImage = "http://realpinkaz.com/wp-content/uploads/olde-key-clip-art-at-clker-vector-clip-art-online-royalty-key-cartoon.svg";
		var d = document.createElement("div");
		d.className = "collectable key";
		d.setAttribute('data-collected', false);
		d.innerHTML = ('<div class="overlay"></div>' +
			'<div class="material"><img src="' + keyImage + '"></div>');
		return d;
	}

	Inventory.prototype.createDisplay = function(obj){
		var {id, url, collected, score} = obj;
		var d = document.createElement("div");
		d.className = "collectable";
		d.setAttribute('data-collected', collected);
		d.innerHTML = ('<div class="overlay"><p> +' + score + '</p></div>' +
		'<div class="material"><img src="' + url + '"></div>');
		return d;
	}

	// notified by collectable when it is collected
	Inventory.prototype.notification = function(collectable){
		// console.log("Inventory says ", collectable, "is collected");
		this.panel[collectable.id].setAttribute('data-collected', collectable.collected);
		this.collectedTypes[collectable.type] = true;
	}

	Inventory.prototype.collected_all_types = function(){
		var types = this.collectedTypes;
		for(var ct in types){
			if(!types[ct])return false;
		}
		return true;
	}

	Inventory.prototype.giveKey = function(){
		if(this.hasKey)return;
		
		this.hasKey = true;
		this.key.setAttribute('data-collected', true);

	}

	Inventory.prototype.dispose = function(){
		console.log("dispose inventory");
		removeClass(this.container, "active");
		var scope = this;
		setTimeout(() => {
			var c = Array.from(scope.container.children);
			c.forEach(e => e.remove());
		}, 1000);
	}


	/*****
		Collectable Item
	****/
	// Collectable object constructor
	function Collectable(x, y, index, url, loader, score, type){
		this.x = x;
		this.y = y;
		this.id = null;
		this.index = index;
		this.url = url;
		this.collectableMaterial = new THREE.MeshStandardMaterial( {map: loader.load(url)});
		this.score = score;
		this.collected = false;
		this.subjects = [];
		this.type = type; // uses itemTypes[type]
	}

	Collectable.prototype.action = function() {
		console.log(this);
		this.collected = true;
		// alert("You collected Collectable of ID : " + this.id +  "\n You get " +  this.score +  " points");
		
		// notify every listener
		this.subjects.forEach(f => f(this));
	};

	Collectable.prototype.hook = function(f){
		this.subjects.push(f);
	}

	var itemTypes = [{
		material: "./images.jpeg",
		score: 10,
		quantity: 4,
	},
	{
		material: "https://previews.123rf.com/images/iloveotto/iloveotto1703/iloveotto170301151/73964767-brown-antique-wall-materials-textures.jpg",
		score: 20,
		quantity: 4,
	},
	{
		material: "https://www.textures.com/system/gallery/photos/Substance/127268/Substance0079_5_download600.jpg",
		score: 30,
		quantity: 2,
	},
	{
		material: 'https://farm3.staticflickr.com/2546/4175426037_7988483c39.jpg',
		score: 40,
		quantity: 2,
	},
	{
		material: "https://i.pinimg.com/originals/8f/0d/ab/8f0dab62e8e3a0485e02d22b0eb69c7e.jpg",
		score: 50,
		quantity: 2,
	},
	{
		material: "https://www.sketchuptextureclub.com/public/texture_f/texture-wrinkled-paper-seamless.jpg",
		score: 100,
		quantity: 1,
	}]

	// create collectables
	function createCollectiblesList(empty_positions){		
		const loader = new THREE.TextureLoader();
		var rand_num = function(upper){
			return Math.floor(Math.random()*(upper + 1));
		}

		// create map with every position empty
		

		function find_rand_empty(){
			var x = rand_num(MAZE_DIMS - 1);
			var y = rand_num(MAZE_DIMS - 1);
			var a = 0;
			while(empty_positions[x][y] != 0 && a < MAZE_DIMS*MAZE_DIMS){
				a += 1;
				x = rand_num(MAZE_DIMS - 1);
				y = rand_num(MAZE_DIMS - 1);
			}
			if(a == MAZE_DIMS*MAZE_DIMS){
				console.log("no empty spots left!");
			}
			return [x, y]
		}

		function _create_({material, score}, index, type){
			var [x, y] = find_rand_empty();
			empty_positions[x][y] = 1;
			return new Collectable(x, y, index, material, loader, score, type);
		}

		var collectables = [];
		var k = 0;
		for(var i in itemTypes){
			var item = itemTypes[i];
			for(var j = 0; j < item.quantity; j++){
				collectables.push(_create_(item, k, i));
				k++;
			}
		}

		return collectables;
	}


	// place collectable graphics on screen
	function placeCollectableGraphics(scene, collectables){
		var collectableGeometry = new THREE.BoxGeometry( 0.25, 0.25, 0.25 );
	   //const loader = new THREE.TextureLoader();
	   // var collectableMaterial= new THREE.MeshPhongMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')});
	   //var collectableMaterial=new THREE.MeshStandardMaterial({color:"red"});
	   collectables.forEach(function(collectable){
	   	var collectableObject = new THREE.Mesh(collectableGeometry,collectable.collectableMaterial);
	   	collectable.id=collectableObject.id;
	   	collectableObject.name='collect';
	   	collectableObject.position.z = collectable.x;
	   	collectableObject.position.x = collectable.y;
	   	scene.add(collectableObject);
	   });
	   return collectables;
	}

	// call if any collectible collided
	function processCollectableCollisions(x, y,collectables,scene){
		collectables.forEach(function(collectable,index){
			if(collectable.x == x && collectable.y == y){
	         collectable.action(); //Run the object's event
	         var id=collectable.id;
	         //var collectableObject = scene.getObjectById( collectables.id );
	         // scene.remove(collectableObject); //Remove graphics from scene
	         collectables.splice(index,1); //Remove collectable from list
	    	}
		    var obj;
		    scene.traverse(function (object){	
		     	if (object.id==id){
		     		obj=object;
		     	}
		     });
	    	scene.remove(obj);
	 	});
		return collectables;
	}

	function createDoor(scene, x=-0.3, y=0, z=-0.465){
		var size = (x) => [x, 2*x];
		var doorGeometry = new THREE.PlaneGeometry(...size(0.25),0.1);
		// scene.add(doorGeometry);

		const loader = new THREE.TextureLoader();
		var doorMaterial = new THREE.MeshPhongMaterial({map: loader.load('http://textures101.com/textures/Doors/Wooden_Doors/Single_Old/2011/6/13/tn1_doormossy_fwhqk.jpg'),});
		var door = new THREE.Mesh(doorGeometry,doorMaterial);
		door.position.z=z;
		door.position.x=x;
		door.position.y=y;
		scene.add(door);
	}

	function displayMessage(str, ...options){
		
		var container = div();
		container.className = "box-cont";
		var box = div();
		box.className = "box";
		
		var optionDiv = div();
		optionDiv.className = "options";
		options.forEach(([name, handler]) => {
			var a = make('a');
			a.className = "option";
			// var d = div();
			a.innerText = name;
			a.addEventListener('click', () => {
				container.className += " fade-out";
				setTimeout( () => {
					container.remove();
					handler();
				}, 800);
			});
			// a.appendChild(d);
			optionDiv.appendChild(a);
		})
		

		var msgDiv = div();
		msgDiv.className = "message";
		msgDiv.innerHTML = '<p>' + str + '</p>';
		box.appendChild(msgDiv);
		box.appendChild(optionDiv);
		container.appendChild(box);
		document.body.appendChild(container);
		if(optionDiv.children.length != 0)
			optionDiv.children[0].focus();
	}

function Obstacle(x, y, index, url, loader, score, type){
		this.x = x;
		this.y = y;
		this.id = null;
		this.index = index;
		this.url = url;
		this.obstacleMaterial = new THREE.MeshStandardMaterial({ color: "#FFF", transparent: true, side: THREE.DoubleSide, alphaTest: 0.0 });
		var alphaMap = new THREE.TextureLoader().load(url);
		this.obstacleMaterial.alphaMap = alphaMap;
		this.obstacleMaterial.alphaMap.magFilter = THREE.NearestFilter;
		this.obstacleMaterial.alphaMap.wrapT = THREE.RepeatWrapping;
		this.obstacleMaterial.alphaMap.repeat.y = 1;
		this.score = score;
		this.collected = false;
		this.subjects = [];
		this.type = type; // uses obstacleTypes[type]
	}

	Obstacle.prototype.action = function() {
		console.log(this);
		this.collected = true;
		// alert("You collected Obstacle of ID : " + this.id +  "\n You get " +  this.score +  " points");
		
		// notify every listener
		this.subjects.forEach(f => f(this));
	};

	Obstacle.prototype.hook = function(f){
		this.subjects.push(f);
	}

	var obstacleTypes = [{
		material: "https://cdn.wallpapersafari.com/30/15/ZlxWtg.png",
		score: -5,
		quantity: 4,
	},
	{
		material: "https://d2v9y0dukr6mq2.cloudfront.net/video/thumbnail/3xEGOGX/videoblocks-3d-metal-mesh-metal-grid-fence-dynamic-steel-pipe-intertwined-on-black-background-animation-abstract-illustration-seamless-loop_sky-mfvnz_thumbnail-full01.png",
		score: -10,
		quantity: 4,
	}]

	// create obstacles
	function createObstaclesList(empty_positions){		
		const loader = new THREE.TextureLoader();
		var rand_num = function(upper){
			return Math.floor(Math.random()*(upper + 1));
		}

		// create map with every position empty
		//var empty_positions = (new Array(MAZE_DIMS)).fill(0).map(() => new Array(MAZE_DIMS).fill(0))

		function find_rand_empty(){
			var x = rand_num(MAZE_DIMS - 1);
			var y = rand_num(MAZE_DIMS - 1);
			var a = 0;
			while(empty_positions[x][y] != 0 && a < MAZE_DIMS*MAZE_DIMS){
				a += 1;
				x = rand_num(MAZE_DIMS - 1);
				y = rand_num(MAZE_DIMS - 1);
			}
			if(a == MAZE_DIMS*MAZE_DIMS){
				console.log("no empty spots left!");
			}
			return [x, y]
		}

		function _create_({material, score}, index, type){
			var [x, y] = find_rand_empty();
			empty_positions[x][y] = 1;
			return new Obstacle(x, y, index, material, loader, score, type);
		}

		var obstacles = [];
		var k = 0;
		for(var i in obstacleTypes){
			var item = obstacleTypes[i];
			for(var j = 0; j < item.quantity; j++){
				obstacles.push(_create_(item, k, i));
				k++;
			}
		}

		return obstacles;
	}


	// place obstacle graphics on screen
	function placeObstacleGraphics(scene, obstacles){
		var obstacleGeometry = new THREE.BoxGeometry(1.0, 0.5 ,1.0);
	   //const loader = new THREE.TextureLoader();
	   // var obstacleMaterial= new THREE.MeshPhongMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')});
	   //var obstacleMaterial=new THREE.MeshStandardMaterial({color:"red"});
	   obstacles.forEach(function(obstacle){
	   	var obstacleObject = new THREE.Mesh(obstacleGeometry,obstacle.obstacleMaterial);
	   	obstacle.id=obstacleObject.id;
	   	obstacleObject.name='obstacle';
	   	obstacleObject.position.z = obstacle.x;
	   	obstacleObject.position.x = obstacle.y;
	   	console.log(obstacle.x,obstacle.y);
	   	scene.add(obstacleObject);
	   });
	   return obstacles;
	}

	// call if any collectible collided
	function processObstacleCollisions(x, y,obstacles,scene){
		obstacles.forEach(function(obstacle,index){
			if(obstacle.x == x && obstacle.y == y){
	         obstacle.action(); //Run the object's event
	         var id=obstacle.id;
	         //var obstacleObject = scene.getObjectById( obstacles.id );
	         // scene.remove(obstacleObject); //Remove graphics from scene
	         obstacles.splice(index,1); //Remove obstacle from list
	    	}
		    var obj;
		    scene.traverse(function (object){	
		     	if (object.id==id){
		     		obj=object;
		     	}
		     });
	    	scene.remove(obj);
	 	});
		return obstacles;
	}

</script>

<script src="js/utility.js"></script>

</head>
<body onload="game();" onkeydown="doKeyDown(event);" onkeyup="doKeyUp(event);">
	<div id="score"><span>Score</span><p></p></div>
	<canvas id="mazeCanvas" width=1300 height=600></canvas>
	<div id="inventory"></div>
</body>
</html>
