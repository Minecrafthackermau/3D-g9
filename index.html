<html>
<head>
	<title>into the Maze</title>
	<style>
	*{
		margin: 0;
	}
	body{
		width: 100vw;
		height: 100vh;
	}
	div#score{
		position: absolute;
	    right: 0;
	    top: 0;
	    background: #000;
		opacity: 0.95;
	    width: 200px;
	    height: 70px;
	    border-bottom-left-radius: 6px;
	    border-left: 2px solid #fff;
	    border-bottom: 5px solid #fff;
	    color: #88ff64;
	    text-align: center;
	    vertical-align: middle;
	    /* justify-content: center; */
	    display: flex;
	    justify-content: center;
	    align-items: center;
	    font-size: 2em;
	    font-family: monospace;
	}
	div#score span{
		position: absolute;
		top:0;
		left: 0;
		font-size: 0.75em;
		font-variant: small-caps;
		padding: 3px 6px;

	}

	div#inventory{
		position: absolute;
		bottom: 0;
		right: 0;
		display: flex;
		border-top-left-radius: 6px;
		background: #000;
		opacity: 0.95;
		border-left: 2px solid #fff;
		border-top: 2px solid #fff;
		padding: 10px;
		/*width: 300px;*/
		flex-wrap: wrap;
	}

	.collectable{
		/*padding: 10px;*/
		margin: 10px;
		position: relative;
		background: #000;
		
	}
	.overlay{
		position: absolute;
		top:0;
		left:0;
		width: 100%;
		height: 100%;
		background: transparent;
		font-size: 0;
	}
	.material img{
		width: 50px;
		height: 50px;
	}

	.collectable[data-collected=false] .overlay{
		background: #000;
		opacity: 0.95;
		border: 1px solid #88ff64;
		color: #ddd;
	    font-family: monospace;
	    display: flex;
	    justify-content: center;
	    align-items: center;
	    font-size: 1.1em;
	}

	.key{
		background: #fff;
	    /*border: 2px solid #f00; */
	    border-radius: 50%;
	}

	.key .overlay{
		border-color: #f00 !important;
		border-radius: 50%;
	}

	.key .overlay{
		transition: all 1s linear;
		
	}

	.box-cont{
		position: absolute;
	    display: flex;
	    -webkit-justify-content: center;
	    justify-content: center;
	    align-items: center;
	    background: #000;
	    top: 0;
	    left: 0;
	    width: 100vw;
	    height: 100vh;
	    color: #88ff64;
	    opacity: 1;
	    transition: all 1s linear;
	}

	.box-cont.fade-out{
		opacity: 0;
	}

	.box{
		/* border: 1px solid #fff; */
	    font-family: arial;
	    padding: 10px;
	    border-radius: 6px;
	}
	.box .options{
		display: flex;
		-webkit-justify-content: space-evenly;
		        justify-content: space-evenly;
	}

	.box .options *{
		margin: 10px;
	    /* border: 1px solid #fff; */
	    padding: 10px;
	    border-radius: 3px;
	    transition: all 1s linear;
	}

	.box .option:hover{
		background: #3c3c3c;
	}	

</style>
<script src="js/three.min.js"></script>

<script>
	const MAZE_DIMS = 10;
	var playerInput = new Object();
	const WAITING = 1;
	const TURNING_RIGHT = 2;
	const TURNING_LEFT = 3;
	const MOVING_FORWARD = 4;
	const FADING = 12;
	const DONE = 11;
	var state = WAITING;
	
	var currentDirection = 0;
	var turningArc = 0;
	
	const NORTH = 100;
	const EAST = 101;
	const WEST = 102;
	const SOUTH = 103;
	
	var direction = NORTH;
	
	var walkDistance = 0;
	var startX = 0;
	var startZ = 0;

	var last_update = Date.now();


	var player = {};
	player.gridX = 0;
	player.gridY = 0;
	player.direction = NORTH;

	var flag=0;

	var d;
	function createDoor(scene){
		var size = (x) => [x, 2*x];
		var doorGeometry = new THREE.PlaneGeometry(...size(0.25),0.1);
		// scene.add(doorGeometry);

		const loader = new THREE.TextureLoader();
		var doorMaterial = new THREE.MeshPhongMaterial({map: loader.load('http://textures101.com/textures/Doors/Wooden_Doors/Single_Old/2011/6/13/tn1_doormossy_fwhqk.jpg'),});
		var door = new THREE.Mesh(doorGeometry,doorMaterial);
		door.position.z=-0.465;
		door.position.x=-0.3;
		door.position.y=0;
		d = door;
		// door.rotation.x=Math.PI/2;
		scene.add(door);
	}

	function displayMessage(str, ...options){
		var div = () => document.createElement('div');
		var container = div();
		container.className = "box-cont";
		var box = div();
		box.className = "box";
		
		var optionDiv = div();
		optionDiv.className = "options";
		options.forEach(([name, handler]) => {
			var d = div();
			d.className = "option";
			d.innerText = name;
			d.addEventListener('click', () => {
				container.className += " fade-out";
				setTimeout( () => {
					container.remove();
					handler();
				}, 800);
			});
			optionDiv.appendChild(d)
		})
		var msgDiv = div();
		msgDiv.className = "message";
		msgDiv.innerHTML = '<p>' + str + '</p>';
		box.appendChild(msgDiv);
		box.appendChild(optionDiv);
		container.appendChild(box);
		document.body.appendChild(container);
	}

	/***

	Initial function that gets called to start the game

	***/

	var $$ = (e) => document.querySelector(e);
	function runMaze(){
	    // get HTML canvas element and set size
	    var mazeCanvas = document.getElementById("mazeCanvas");
	    mazeCanvas.width = document.body.offsetWidth;
	    mazeCanvas.height = document.body.offsetHeight;

	    // create scene, WEBGL renderer and camera
	    var scene = new THREE.Scene();
	    var renderer = new THREE.WebGLRenderer({ canvas: mazeCanvas });
	    var camera = new THREE.PerspectiveCamera( 75, mazeCanvas.width/mazeCanvas.height, 0.1, 1000 );

	    var mazeGrid = createMazeGrid(MAZE_DIMS, MAZE_DIMS);
	 	placeWallGraphics(scene, mazeGrid);	    

	    var collectables = createCollectiblesList();
	    collectables=placeCollectableGraphics(scene, collectables);
	    var inventory = new Inventory($$("#inventory"), collectables);

	    var score_man = new ScoreManager($$("#score p"), collectables, {
	    	aim: 200,
	    	action: inventory.giveKey
	    });
	    var nobox = true;

	    var door = createDoor(scene); // create door at 0,0,0

	   	// create Light source
	   	var playerPointLight = new THREE.PointLight();
	   	playerPointLight.position.set(0,0,0 );
	   	scene.add( playerPointLight );

	   	var render = function () {
	   		var now = Date.now();
	   		var deltaTime = now - last_update;
	   		last_update = now;

	   		
			if(state == WAITING){  // waiting for user input
				   // if player has given an input, make a move
				if(playerInput.left){
				   	state = TURNING_LEFT;
				   	switch(direction){
				   		case NORTH:
				   		direction = WEST;
				   		break;
				   		case EAST:
				   		direction = NORTH;
				   		break;
				   		case SOUTH:
				   		direction = EAST;
				   		break;
				   		case WEST:
				   		direction = SOUTH;
				   		break;
				   	}
					   player.direction = direction; //Sync player and camera
				}
				else if(playerInput.right){
					state = TURNING_RIGHT;
					switch(direction){
						case NORTH:
						direction = EAST;
						break;
						case EAST:
						direction = SOUTH;
						break;
						case SOUTH:
						direction = WEST;
						break;
						case WEST:
						direction = NORTH;
						break;
					}
				   player.direction = direction; //Sync player and camera
				}
				else if (playerInput.up ){
					if(validMove(mazeGrid, player.gridX, player.gridY, player.direction)){
						walkingDistance = 0;
						startX = camera.position.x;
						startZ = camera.position.z;
						state = MOVING_FORWARD;
						switch(direction){
							case NORTH:
							player.gridX--;
							break;
							case EAST:
							player.gridY++;
							break;
							case SOUTH:
							player.gridX++;
							break;
							case WEST:
							player.gridY--;
							break;
						}
					}else{
						// shake animation 
					}
				}else if(playerInput.enter){
					// console.log(player);
					if(inventory.hasKey && direction == NORTH
						&& player.gridX == 0 && player.gridY == 0){
						state = FADING;
						// console.log("Yay, level done!");
					}
				}
			}

			if(state == FADING){
				var ops = scene.children.map( ({material}) => {
					if(material){
						material.transparent = true;	
						material.opacity -= 0.1;
						return material.opacity;
					}
					return 0;
				}).filter(e => e > 0);

				if(ops.length == 0){
					state = DONE;
				}
			}
			if(state == DONE){
				if(nobox){
					nobox = false;
					var doNothing = () => {};

					displayMessage("Ready for the next one?", ["Yes", doNothing], ["No", doNothing]);
				}
			}

			if(state == TURNING_LEFT){
				turningArc += Math.PI/2  * deltaTime/1000;
				if(turningArc >= Math.PI/2){
					turningArc = Math.PI/2;
					currentDirection = currentDirection + turningArc;
					turningArc = 0;
					state = WAITING;
				}

				camera.rotation.y = currentDirection + turningArc;
			}

			if(state == TURNING_RIGHT){
				turningArc += Math.PI/2  * deltaTime/1000;
				if(turningArc >= Math.PI/2){
					turningArc = Math.PI/2;
					currentDirection = currentDirection - turningArc;
					turningArc = 0;
					state = WAITING;
				}

				camera.rotation.y = currentDirection - turningArc;
			}

			if(state == MOVING_FORWARD)
			{

				walkingDistance += 1 * deltaTime/1000;
				if(walkingDistance >= 1){
					walkingDistance = 1;
					state = WAITING;
					collectables=processCollectableCollisions(player.gridX, player.gridY,collectables,scene)
				}
				switch(direction){
					case NORTH:
					camera.position.z = startZ - walkingDistance;
					break;
					case EAST:
					camera.position.x = startX + walkingDistance;
					break;
					case SOUTH:
					camera.position.z = startZ + walkingDistance;
					break;
					case WEST:
					camera.position.x = startX - walkingDistance;
					break;
				}
				playerPointLight.position.x = camera.position.x;
				playerPointLight.position.y = camera.position.y;
				playerPointLight.position.z = camera.position.z;
				// 	collectables.forEach(function(collectable){
					
				//    var collectableObject = scene.getObjectById( collectables.id);
				//    if (flag++<10) console.log(collectableObject.id);
				//    collectableObject.rotation.x += 2 * deltaTime/1000;
				//    collectableObject.rotation.y += 2 * deltaTime/1000;

				// });
			}

			scene.traverse (function (object){	
				if (object.name==='collect'){
					object.rotation.x += 2 * deltaTime/1000;
					object.rotation.y += 2 * deltaTime/1000;
				}

			});
			renderer.render(scene, camera);
			// recursive call [ call when js animation micro-calls are done]
			requestAnimationFrame( render );
		};

		render();
	}

	// check if move is
	function validMove(mazeGrid, x, y, direction){
		if(direction == NORTH)
		{
			return !mazeGrid[x][y].northWall;
		}
		else if(direction == EAST)
		{
			return !mazeGrid[x][y].eastWall;
		}
		else if(direction == SOUTH)
		{
			return !mazeGrid[x][y].southWall;
		}
		else if(direction == WEST)
		{
			return !mazeGrid[x][y].westWall;
		}
		return false;
	}


	// create maze
	function createMazeGrid(width, height){
		function MazeCell(northWall, eastWall, southWall, westWall){
			this.northWall = northWall;
			this.eastWall = eastWall;
			this.southWall = southWall;
			this.westWall = westWall;
		}
		MazeCell.prototype.print = function() {
			// var str = "";
			var str = ["   ", "    ", "   "];
			if(this.northWall){
				str[0] = " -- ";
			}

			if(this.westWall){
				str[1] = "|" + str[1].slice(1);
				console.log(str[1])
			}

			if(this.eastWall){
				str[1] =  str[1].slice(0, 3) + "|";
				// str[1][3] += '|';
			}
			
			if(this.southWall){
				str[2] = " -- ";
			}
			
			return str;
		};
		var mazeGrid = Array(height);

		for( var i = 0; i<height; i++){
			var row = Array(width);
			for(var j = 0; j<width; j++){
				row[j] = new MazeCell(true,true,true,true);
			}
			mazeGrid[i] = row;

		}
		for( var i = 0; i<height; i++){
			for(var j = 0; j<width; j++){
		      if(i>0 && j>0){ //If it is not an edge cell open a passage randomly
		      	if(Math.random()>0.5){
		      		mazeGrid[i][j].northWall=false;
		      		mazeGrid[i-1][j].southWall=false;
		      	}
		      	else{
		      		mazeGrid[i][j].westWall=false;
		      		mazeGrid[i][j-1].eastWall=false;
		      	}
		      }
		      else if(j > 0){ //If it is along the north edge open a west passage
		      	mazeGrid[i][j].westWall=false;
		      	mazeGrid[i][j-1].eastWall=false;
		      }
		      else if(i > 0){ //If it is along the west edge open a north passage
		      	mazeGrid[i][j].northWall=false;
		      	mazeGrid[i-1][j].southWall=false;
		      }
		  }
		}
		
		console.log(mazeGrid.map(row=> row.map(cell=> cell.print()).reduce((acc, ele) => {
			ele.forEach((e, i) => acc[i] += e);
			return acc;
		}, ["", "", ""])));

		return mazeGrid;
	}


	// place wall graphics on screen
	function placeWallGraphics(scene, mazeGrid){

		var wallGeometry = new THREE.BoxGeometry( 1.0, 0.5 ,0.06);
		const loader = new THREE.TextureLoader();
		var wallMaterial = new THREE.MeshPhongMaterial({map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2zL8u2_YcU9nXs1KpYGrDWqRO3L55FC4rnewIqV6AC7TjzdHO2w'),});

		mazeGrid.forEach(function(mazeRow, rowCount){
			mazeRow.forEach(function(mazeCell, colCount){
				if(mazeCell.northWall)
					placeWall(colCount, rowCount, 'n');
				if(mazeCell.eastWall)
					placeWall(colCount, rowCount, 'e');
				if(mazeCell.southWall)
					placeWall(colCount, rowCount, 's');
				if(mazeCell.westWall)
					placeWall(colCount, rowCount, 'w');
				var floorGeometry=new THREE.PlaneGeometry(1,1,0.1);
				const loader = new THREE.TextureLoader();
				var floorMaterial = new THREE.MeshPhongMaterial({map: loader.load('https://www.tonytextures.com/free-texture-gallery/stone/Stone_Texture_A_P2140754.JPG'),});
				var floor= new THREE.Mesh(floorGeometry,floorMaterial);
				floor.position.z=rowCount;
				floor.position.x=colCount;
				floor.position.y=-0.25;
				floor.rotation.x=-Math.PI/2;
				scene.add(floor);
			});
		});

		function placeWall(x,y,direction){
			var wall = new THREE.Mesh( wallGeometry, wallMaterial );
			wall.name='wall';
			wall.position.z = y*1;
			wall.position.x = x*1;
			if(direction == 'n'){
				wall.position.z -= 0.5;
			}
			else if(direction == 'e'){
				wall.position.x += 0.5;
				wall.rotation.y = -Math.PI/2;
			}
			else if(direction == 's'){
				wall.position.z += 0.5;
				wall.rotation.y = Math.PI;
			}
			else if(direction == 'w'){
				wall.position.x -= 0.5;
				wall.rotation.y = Math.PI/2;
			}
			else{
				return false;
			}

			scene.add(wall);
		}
	}

	/*****
		Score Manager
	****/
	function ScoreManager(ele, collectables, target){

		// hook a notification function on the collectables
		collectables.forEach(m => m.hook(this.notification.bind(this)))
		this.ele = ele;
		var {aim, action}= target;
		this.aim = aim;
		this.action = action;
		this.update(0);
	}
	
	// notified by collectable when it is collected
	ScoreManager.prototype.notification = function(collectable){
		this.update(this.score + collectable.score);
		console.log("ScoreManager says  score is ", this.score);
		if(this.score >= this.aim){
			this.action();
		}
	}

	ScoreManager.prototype.update = function(n){
		this.score = n;
		this.ele.innerText = this.score;
	}

	/*****
		Inventory Manager
	****/
	function Inventory(container, collectables){
		this.collectables = collectables;
		this.collectedTypes = {}

		// hook a notification function on the collectables
		this.collectables.forEach(m => {
			this.collectedTypes[m.type] = false;
			m.hook(this.notification.bind(this))
		});
		this.panel = {};
		var scope = this;

		this.collectables.map(ele => {
			var o = scope.createDisplay(ele);
			this.panel[ele.id] = o;
			return o;
		}).forEach(ele => {
			container.appendChild(ele);
		})
		this.key = this.createKey();
		container.appendChild(this.key);

		this.hasKey = false;

		// will be called by another function.
		// so, bind this to my scope.
		this.giveKey = this.giveKey.bind(this);

	}

	Inventory.prototype.createKey = function(){
		var keyImage = "http://realpinkaz.com/wp-content/uploads/olde-key-clip-art-at-clker-vector-clip-art-online-royalty-key-cartoon.svg";
		var d = document.createElement("div");
		d.className = "collectable key";
		d.setAttribute('data-collected', false);
		d.innerHTML = ('<div class="overlay"></div>' +
			'<div class="material"><img src="' + keyImage + '"></div>');
		return d;
	}

	Inventory.prototype.createDisplay = function(obj){
		var {id, url, collected, score} = obj;
		var d = document.createElement("div");
		d.className = "collectable";
		d.setAttribute('data-collected', collected);
		d.innerHTML = ('<div class="overlay"><p> +' + score + '</p></div>' +
		'<div class="material"><img src="' + url + '"></div>');
		return d;
	}

	// notified by collectable when it is collected
	Inventory.prototype.notification = function(collectable){
		console.log("Inventory says ", collectable, "is collected");
		this.panel[collectable.id].setAttribute('data-collected', collectable.collected);
		this.collectedTypes[collectable.type] = true;
	}

	Inventory.prototype.collected_all_types = function(){
		var types = this.collectedTypes;
		for(var ct in types){
			if(!types[ct])return false;
		}
		return true;
	}

	Inventory.prototype.giveKey = function(){
		if(this.hasKey)return;
		
		this.hasKey = true;
		this.key.setAttribute('data-collected', true);

	}


	/*****
		Collectable Item
	****/
	// Collectable object constructor
	function Collectable(x, y, index, url, loader, score, type){
		this.x = x;
		this.y = y;
		this.id = null;
		this.index = index;
		this.url = url;
		this.collectableMaterial = new THREE.MeshStandardMaterial( {map: loader.load(url)});
		this.score = score;
		this.collected = false;
		this.subjects = [];
		this.type = type; // uses itemTypes[type]
	}

	Collectable.prototype.action = function() {
		console.log(this);
		this.collected = true;
		// alert("You collected Collectable of ID : " + this.id +  "\n You get " +  this.score +  " points");
		
		// notify every listener
		this.subjects.forEach(f => f(this));
	};

	Collectable.prototype.hook = function(f){
		this.subjects.push(f);
	}

	var itemTypes = [{
		material: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA',
		score: 10,
		quantity: 4,
	},
	{
		material: "https://previews.123rf.com/images/iloveotto/iloveotto1703/iloveotto170301151/73964767-brown-antique-wall-materials-textures.jpg",
		score: 20,
		quantity: 4,
	},
	{
		material: "https://www.textures.com/system/gallery/photos/Substance/127268/Substance0079_5_download600.jpg",
		score: 30,
		quantity: 2,
	},
	{
		material: 'https://farm3.staticflickr.com/2546/4175426037_7988483c39.jpg',
		score: 40,
		quantity: 2,
	},
	{
		material: "https://i.pinimg.com/originals/8f/0d/ab/8f0dab62e8e3a0485e02d22b0eb69c7e.jpg",
		score: 50,
		quantity: 2,
	},
	{
		material: "https://www.sketchuptextureclub.com/public/texture_f/texture-wrinkled-paper-seamless.jpg",
		score: 100,
		quantity: 1,
	}]

	// create collectables
	function createCollectiblesList(){		
		const loader = new THREE.TextureLoader();
		var rand_num = function(upper){
			return Math.floor(Math.random()*(upper + 1));
		}

		// create map with every position empty
		var empty_positions = (new Array(MAZE_DIMS)).fill(0).map(() => new Array(MAZE_DIMS).fill(0))

		function find_rand_empty(){
			var x = rand_num(MAZE_DIMS - 1);
			var y = rand_num(MAZE_DIMS - 1);
			var a = 0;
			while(empty_positions[x][y] != 0 && a < MAZE_DIMS*MAZE_DIMS){
				a += 1;
				x = rand_num(MAZE_DIMS - 1);
				y = rand_num(MAZE_DIMS - 1);
			}
			if(a == MAZE_DIMS*MAZE_DIMS){
				console.log("no empty spots left!");
			}
			return [x, y]
		}

		function _create_({material, score}, index, type){
			var [x, y] = find_rand_empty();
			empty_positions[x][y] = 1;
			return new Collectable(x, y, index, material, loader, score, type);
		}

		var collectables = [];
		var k = 0;
		for(var i in itemTypes){
			var item = itemTypes[i];
			for(var j = 0; j < item.quantity; j++){
				collectables.push(_create_(item, k, i));
				k++;
			}
		}

		return collectables;
	}


	// place collectable graphics on screen
	function placeCollectableGraphics(scene, collectables){
		var collectableGeometry = new THREE.BoxGeometry( 0.25, 0.25, 0.25 );
	   //const loader = new THREE.TextureLoader();
	   // var collectableMaterial= new THREE.MeshPhongMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')});
	   //var collectableMaterial=new THREE.MeshStandardMaterial({color:"red"});
	   collectables.forEach(function(collectable){
	   	var collectableObject = new THREE.Mesh(collectableGeometry,collectable.collectableMaterial);
	   	collectable.id=collectableObject.id;
	   	collectableObject.name='collect';
	   	collectableObject.position.z = collectable.x;
	   	collectableObject.position.x = collectable.y;
	   	scene.add(collectableObject);
	   });
	   return collectables;
	}

	// call if any collectible collided
	function processCollectableCollisions(x, y,collectables,scene){
		collectables.forEach(function(collectable,index){
			if(collectable.x == x && collectable.y == y){
	         collectable.action(); //Run the object's event
	         var id=collectable.id;
	         //var collectableObject = scene.getObjectById( collectables.id );
	         // scene.remove(collectableObject); //Remove graphics from scene
	         collectables.splice(index,1); //Remove collectable from list
	    	}
		    var obj;
		    scene.traverse(function (object){	
		     	if (object.id==id){
		     		obj=object;
		     	}
		     });
	    	scene.remove(obj);
	 	});
		return collectables;
	}


</script>

<script src="js/utility.js"></script>
</head>
<body onload="runMaze();" onkeydown="doKeyDown(event);" onkeyup="doKeyUp(event);">
	<div id="score"><span>Score</span><p></p></div>
	<canvas id="mazeCanvas" width=1300 height=600></canvas>
	<div id="inventory"></div>
</body>
</html>
