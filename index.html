<html>
<head>
   <title>into the Maze</title>
   <script src="js/three.min.js"></script>
   <script>

   	var playerInput = new Object();
   	const WAITING = 1;
	const TURNING_RIGHT = 2;
	const TURNING_LEFT = 3;
	var state = WAITING;
	var currentDirection = 0;
	var turningArc = 0;
	const NORTH = 100;
	const EAST = 101;
	const WEST = 102;
	const SOUTH = 103;
	var direction = NORTH;
	const MOVING_FORWARD = 4;
	var walkDistance = 0;
	var startX = 0;
	var startZ = 0;

	var last_update = Date.now();

	var player = {};
	player.gridX = 0;
	player.gridY = 0;
	player.direction = NORTH;

	var flag=0;


		function doKeyDown(event){
		   var keynum;

		   if(window.event){ //Browser is IE
		      keynum = event.keyCode;
		   }
		   else{
		      keynum = event.which;
		   }

		   if(keynum == 37){
		      playerInput.left = 1;
		   }
		   else if(keynum == 38){
		      playerInput.up = 1;
		   }
		   else if(keynum == 39){
		      playerInput.right = 1;
		   }
		   else if(keynum == 40){
		      playerInput.down = 1;
		   }
		}

		function doKeyUp(event){
		   var keynum;
		   
		   if(window.event){ //Browser is IE
		      keynum = event.keyCode;
		   }
		   else{
		      keynum = event.which;
		   }

		   if(keynum == 37){
		      playerInput.left = 0;
		   }
		   else if(keynum == 38){
		      playerInput.up = 0;
		   }
		   else if(keynum == 39){
		      playerInput.right = 0;
		   }
		   else if(keynum == 40){
		      playerInput.down = 0;
		   }
		}
      

      function runMaze()
      {
      	var mazeCanvas = document.getElementById("mazeCanvas");
      	var scene = new THREE.Scene();
      	var renderer = new THREE.WebGLRenderer({ canvas: mazeCanvas });
      	var camera = new THREE.PerspectiveCamera( 75, mazeCanvas.width/mazeCanvas.height, 0.1, 1000 );
      	var mazeGrid = createMazeGrid();
   		placeWallGraphics(scene, mazeGrid);
   		var collectables = createCollectiblesList();
   		placeCollectableGraphics(scene, collectables);

		var playerPointLight = new THREE.PointLight();
		playerPointLight.position.set( 0, 0, 0 );
		scene.add( playerPointLight );


		var render = function () {
			var now = Date.now();
			var deltaTime = now - last_update;
			last_update = now;
		   requestAnimationFrame( render );

		   
		if(state == WAITING){
		   if(playerInput.left){
			   state = TURNING_LEFT;
			   switch(direction){
			      case NORTH:
			         direction = WEST;
			         break;
			      case EAST:
			         direction = NORTH;
			         break;
			      case SOUTH:
			         direction = EAST;
			         break;
			      case WEST:
			         direction = SOUTH;
			         break;
			   }
			   player.direction = direction; //Sync player and camera
			}
			else if(playerInput.right){
			   state = TURNING_RIGHT;
			   switch(direction){
			      case NORTH:
			         direction = EAST;
			         break;
			      case EAST:
			         direction = SOUTH;
			         break;
			      case SOUTH:
			         direction = WEST;
			         break;
			      case WEST:
			         direction = NORTH;
			         break;
			   }
			   player.direction = direction; //Sync player and camera
			 }
			 else if (playerInput.up && validMove(mazeGrid, player.gridX, player.gridY, player.direction)){
			   walkingDistance = 0;
			   startX = camera.position.x;
			   startZ = camera.position.z;
			   state = MOVING_FORWARD;
			   switch(direction){
			      case NORTH:
			         player.gridX--;
			         break;
			      case EAST:
			         player.gridY++;
			         break;
			      case SOUTH:
			         player.gridX++;
			         break;
			      case WEST:
			         player.gridY--;
			         break;
			   }
			 }
		}
		if(state == TURNING_LEFT){
		   turningArc += Math.PI/2  * deltaTime/1000;
		   if(turningArc >= Math.PI/2){
		      turningArc = Math.PI/2;
		      currentDirection = currentDirection + turningArc;
		      turningArc = 0;
		      state = WAITING;
		   }
		   
		   camera.rotation.y = currentDirection + turningArc;
		}

		if(state == TURNING_RIGHT){
		   turningArc += Math.PI/2  * deltaTime/1000;
		   if(turningArc >= Math.PI/2){
		      turningArc = Math.PI/2;
		      currentDirection = currentDirection - turningArc;
		      turningArc = 0;
		      state = WAITING;
		   }

		   camera.rotation.y = currentDirection - turningArc;
		}

		if(state == MOVING_FORWARD)
		{

		    walkingDistance += 1 * deltaTime/1000;

		   if(walkingDistance >= 1){
		      walkingDistance = 1;
		      state = WAITING;
		      collectables=processCollectableCollisions(player.gridX, player.gridY,collectables,scene)
		   }

		   switch(direction){
		      case NORTH:
		         camera.position.z = startZ - walkingDistance;
		         break;
		      case EAST:
		         camera.position.x = startX + walkingDistance;
		         break;
		      case SOUTH:
		         camera.position.z = startZ + walkingDistance;
		         break;
		      case WEST:
		         camera.position.x = startX - walkingDistance;
		         break;
		   }
		   playerPointLight.position.x = camera.position.x;
			playerPointLight.position.y = camera.position.y;
			playerPointLight.position.z = camera.position.z;
		// 	collectables.forEach(function(collectable){
			
		//    var collectableObject = scene.getObjectById( collectables.id);
		//    if (flag++<10) console.log(collectableObject.id);
		//    collectableObject.rotation.x += 2 * deltaTime/1000;
		//    collectableObject.rotation.y += 2 * deltaTime/1000;
		   
		// });
			


		}

			scene.traverse (function (object)
			{	
			    
			        if (object.name==='collect'){
			            object.rotation.x += 2 * deltaTime/1000;
		   				object.rotation.y += 2 * deltaTime/1000;}
		   
			});

		   renderer.render(scene, camera);
		};



		
		render();

      }


	function validMove(mazeGrid, x, y, direction){
		   if(direction == NORTH)
		   {
		      return !mazeGrid[x][y].northWall;
		   }
		   else if(direction == EAST)
		   {
		      return !mazeGrid[x][y].eastWall;
		   }
		   else if(direction == SOUTH)
		   {
		      return !mazeGrid[x][y].southWall;
		   }
		   else if(direction == WEST)
		   {
		      return !mazeGrid[x][y].westWall;
		   }
		   return false;
		}
	function createMazeGrid(){
	   function MazeCell(northWall, eastWall, southWall, westWall){
	      this.northWall = northWall;
	      this.eastWall = eastWall;
	      this.southWall = southWall;
	      this.westWall = westWall;
	   }

	   var mazeGrid = [Array(2), Array(2)];

	   mazeGrid[0][0] = new MazeCell(true, false, false, true);
	   mazeGrid[0][1] = new MazeCell(true, true, true, false);
	   mazeGrid[1][0] = new MazeCell(false, true, true, true);
	   mazeGrid[1][1] = new MazeCell(false,false,false,false);

	   return mazeGrid;
	}
	function placeWallGraphics(scene, mazeGrid){

  		var wallGeometry = new THREE.BoxGeometry( 1, 0.5 ,0.05);
  		const loader = new THREE.TextureLoader();
		var wallMaterial = new THREE.MeshPhongMaterial({map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS2zL8u2_YcU9nXs1KpYGrDWqRO3L55FC4rnewIqV6AC7TjzdHO2w'),});

	   mazeGrid.forEach(function(mazeRow, rowCount){
	      mazeRow.forEach(function(mazeCell, colCount){
	         if(mazeCell.northWall)
	           placeWall(colCount, rowCount, 'n');
	         if(mazeCell.eastWall)
	           placeWall(colCount, rowCount, 'e');
	         if(mazeCell.southWall)
	            placeWall(colCount, rowCount, 's');
	         if(mazeCell.westWall)
	            placeWall(colCount, rowCount, 'w');
	      });
	   });

   function placeWall(x,y,direction){
	      var wall = new THREE.Mesh( wallGeometry, wallMaterial );
	      wall.name='wall';
	      wall.position.z = y*1;
	      wall.position.x = x*1;
	      if(direction == 'n'){
	         wall.position.z -= 0.5;
	      }
	      else if(direction == 'e'){
	         wall.position.x += 0.5;
	         wall.rotation.y = -Math.PI/2;
	      }
	      else if(direction == 's'){
	         wall.position.z += 0.5;
	         wall.rotation.y = Math.PI;
	      }
	      else if(direction == 'w'){
	         wall.position.x -= 0.5;
	         wall.rotation.y = Math.PI/2;
	      }
	      else{
	         return false;
	      }

	      scene.add(wall);
	   }
	}


	function createCollectiblesList(){
	   var collectables = [];
	   const loader = new THREE.TextureLoader();
	   collectables.push(
	      {
	         x:0,
	         y:1, 
	         id:1,
	         collectableMaterial: new THREE.MeshStandardMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')}),
	         action:function(){alert("You picked up a collectable");},
	      });

	   collectables.push(
	      {		
	         x:1,
	         y:0,
	         id:2,
	         collectableMaterial: new THREE.MeshStandardMaterial( {map: loader.load('https://farm3.staticflickr.com/2546/4175426037_7988483c39.jpg')}),
	         action:function(){alert("You picked up a different collectable");},
	      });

	   return collectables;
	}


	function placeCollectableGraphics(scene, collectables){
	   var collectableGeometry = new THREE.BoxGeometry( 0.25, 0.25, 0.25 );
	   //const loader = new THREE.TextureLoader();
	   // var collectableMaterial= new THREE.MeshPhongMaterial( {map: loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjJzLwvs5JHTGVuezxnv7_zy0qZdS2ytQ25LLMGgMt4bFERLgWCA')});
	   //var collectableMaterial=new THREE.MeshStandardMaterial({color:"red"});
	   collectables.forEach(function(collectable){
	      var collectableObject = new THREE.Mesh(collectableGeometry,collectable.collectableMaterial);
	      collectable.id=collectableObject.id;
	      collectableObject.name='collect';
	      collectableObject.position.z = collectable.x;
	      collectableObject.position.x = collectable.y;
	      scene.add(collectableObject);
	   });
	}

	function processCollectableCollisions(x, y,collectables,scene){
	   collectables.forEach(function(collectable,index){
	      if(collectable.x == x && collectable.y == y){
	         collectable.action(); //Run the object's event
	         id=collectable.id;
	         
	         //var collectableObject = scene.getObjectById( collectables.id );
	         // scene.remove(collectableObject); //Remove graphics from scene
	         collectables.splice(index,1); //Remove collectable from list
	      }
	      var obj;
	         scene.traverse (function (object)
				{	
				    
				        if (object.id==id){
			   				obj=object;
			   			}
			   
				});
	         scene.remove(obj);
	   });
	   return collectables;
	}

      
   </script>
</head>
<body>
<body onload="runMaze();" onkeydown="doKeyDown(event);" onkeyup="doKeyUp(event);">
   <canvas id="mazeCanvas" width=600 height=450 />
</body>
</html>